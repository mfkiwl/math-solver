<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Using requires&lt;&gt; for general overloads</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">4.7.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doxygen_2contributor__help__pages_2require__meta.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Using requires&lt;&gt; for general overloads</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="group__require__meta.html">`requires` template parameters</a> type traits are aliases for <code>std::enable_if_t</code> that have premade conditions for turning on and off function definitions during compilation. These are useful for having generalized templates while still overloading a function or class. You can think of these as "legacy concepts". These are used in a very similar fashion to C++20's <code>requires</code> keyword.</p>
<p><code>requires</code> template parameters are <a href="https://en.cppreference.com/w/cpp/types/enable_if"><code>std::enable_if_t</code></a> aliases such as the following example definition of <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">stan::require_t</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">using </span>require_t = std::enable_if_t&lt;T::value&gt;;</div>
</div><!-- fragment --><p>This differes from <code>std::enable_if_t</code> in that <code>std::enable_if_t</code>'s argument must be boolean, but the alias <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">stan::require_t</a> 's template type <code>T</code> must have a valid boolean member named <code>value</code>. This allows us to directly call <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">stan::require_t</a> with type traits instead of having to do the extra step of accessing the type traits boolean member struct value explicity with calls such as <code>a_type_trait::value</code>.</p>
<p>The most common use case for a <code>requires</code> template parameters is to overload a function or declare specializations of a class. For example, the function below will only work on types derived from <a href="https://eigen.tuxfamily.org/dox/classEigen_1_1DenseBase.html"><code>Eigen::DenseBase</code></a> with only 1 row or column at compile time such as <code>Eigen::Matrix&lt;double, -1, 1&gt;</code> or <code>Eigen::Matrix&lt;double, 1, -1&gt;</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> EigVec, require_eigen_vector_t&lt;EigVec&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> my_func(<span class="keyword">const</span> EigVec&amp; x) {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>requires</code> template parameter is included in the template as a pointer <a href="https://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter">non-type template parameter</a> with a default value of <code>nullptr</code>. This might look a bit odd, but it uses the fact that any non-type template parameter of type <code>void*</code> with a default of <code>nullptr</code> will be ignored by the compiler. Under the hood, if any of the <code>requires</code> template parameters are successful they will return back a type <code>void</code>. So when we pass a type that the <code>requires</code> template parameter accepts we get back a <code>void* = nullptr</code>, which is safely ignored by the compiler. In the case that the type does not satisfy the <code>requires</code> template parameter then the function is removed from the set of possible functions the caller could use via SFINAE. With this scheme we end up having a very nice pattern for writing generic templates for functions while also being able to restrict the set of types that a function can be used for.</p>
<p>For overloading classes and structs with this scheme we create an initial forward definition with a <code>void</code> non-type template parameter. Then the class overloads use the <code>requires</code> template parameter in place of the non-type template parameter.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keywordtype">void</span>&gt;</div>
<div class="line"><span class="keyword">class </span>a_class;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>a_class&lt;T, require_std_vector_st&lt;is_var, T&gt;&gt; {</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>In the above example, <code>a_class</code> has an overload specifically for standard vectors with a <a class="el" href="structstan_1_1scalar__type.html">stan::scalar_type</a> of <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> .</p>
<p>The examples below cover the general themes for all of the <a class="el" href="group__require__meta.html">`requires` template parameters</a> found in the Stan math library. Any <code>*</code> should be thought of as a wildcard where a type traits name is put in its place.</p>
<ul>
<li><code>requires_*_t</code>: A template parameter <code>T</code> must satisfy the <code>requires</code> template parameter in order for the overload to be available.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Works for stan::math::var types</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, require_var_t&lt;T&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> add(T&amp;&amp; x, T&amp;&amp; y) { <span class="keywordflow">return</span> x + y; }</div>
</div><!-- fragment --><ul>
<li><code>require_not_*_t</code> : A template parameter <code>T</code> must <em>not</em> satisfy the <code>requires</code> template parameter in order for the overload to be availabe.</li>
</ul>
<p><em>NOTE:</em> The <code>not</code> version of the <code>requires</code> template parameters should be used sparingly. Often a <code>requires</code> template parameter is used to specify what types a function should accept. Defining a function by the types it cannot accept can make understanding what goes into a function more difficult and error prone.</p>
<div class="fragment"><div class="line"><span class="comment">// Works for anything that is not a std::vector</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, require_not_std_vector_t&lt;T&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> add(T&amp;&amp; x, T&amp;&amp; y) { <span class="keywordflow">return</span> x + y; }</div>
</div><!-- fragment --><ul>
<li><code>require_all_*_t</code> : Takes a parameter pack of types to enable if all types satisfy the check.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Works if T1 and T2 are complex</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2,</div>
<div class="line">  require_all_complex_t&lt;T1, T2&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> add(T1&amp;&amp; x, T2&amp;&amp; y) { <span class="keywordflow">return</span> x + y; }</div>
</div><!-- fragment --><ul>
<li><code>require_any_*_t</code> : Takes a parameter pack of types to enable if any of the types satisfy the check.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Works if either T1 or T2 enherit from EigenBase</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, require_any_eigen_t&lt;T1, T2&gt;* = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> add(T1&amp;&amp; x, T2&amp;&amp; y) { <span class="keywordflow">return</span> x + y; }</div>
</div><!-- fragment --><ul>
<li><code>require_not_any_*_t</code> : Takes a parameter pack of types to enable if any one of the types are not satisfied.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Works if either neither T1 or T2 are arithmetic</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2,</div>
<div class="line">  require_not_any_eigen_row_vector_t&lt;T1, T2&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> add(T1 x, T2 y) { <span class="keywordflow">return</span> x + y; }</div>
</div><!-- fragment --><ul>
<li><code>require_not_all_*_t</code> : Takes a parameter pack of types to enable if all of the types are not satisfied.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Works if neither T1 and T2 are arithmetic</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2,</div>
<div class="line">  require_not_all_arithmetic_t&lt;T1, T2&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> add(T1 x, T2 y) { <span class="keywordflow">return</span> x + y; }</div>
</div><!-- fragment --><p><code>std::vector</code> and <code><a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a></code> types have additional <code>requires</code> template parameters to detect if the <a class="el" href="structstan_1_1value__type.html">stan::value_type</a> (the first underlying type) or the <a class="el" href="structstan_1_1scalar__type.html">stan::scalar_type</a> (the containers underlying scalar type) satisfy a condition to enable a class or function.</p>
<p>The container <code>requires</code> template parameters have an ending at their signature of _vt and _st to symbolize whether you want to inspect the <a class="el" href="structstan_1_1value__type.html">stan::value_type</a> or <a class="el" href="structstan_1_1scalar__type.html">stan::scalar_type</a>. A function that accepts eigen matrices with floating point value types can be defined as</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Mat1, <span class="keyword">typename</span> Mat2,</div>
<div class="line">  require_all_eigen_vt&lt;std::is_floating_point, Mat1, Mat2&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> add(Mat1&amp;&amp; A, Mat2&amp;&amp; B) { <span class="keywordflow">return</span> A + B;}</div>
</div><!-- fragment --><p>A function that accepts standard vectors of <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vectors whose scalar type is <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> types can be defined as</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Vec1, <span class="keyword">typename</span> Vec2,</div>
<div class="line">  require_all_std_vector_vt&lt;is_eigen_vector, Vec1, Vec2&gt;* = <span class="keyword">nullptr</span>,</div>
<div class="line">  require_all_std_vector_st&lt;is_var, Vec1, Vec2&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">auto</span> add(Vec1&amp;&amp; A, Vec2&amp;&amp; B) {</div>
<div class="line">  std::vector&lt;decltype&lt;A[0] + B[0]&gt;&gt; return_vec;</div>
<div class="line">  std::transform(A.begin(), A.end(), B.begin(), return_vec.begin(),</div>
<div class="line">    [](<span class="keyword">auto</span>&amp;&amp; x, <span class="keyword">auto</span>&amp;&amp; y) {</div>
<div class="line">        return x + y;</div>
<div class="line">    });</div>
<div class="line">  <span class="keywordflow">return</span> return_vec;</div>
<div class="line">}</div>
</div><!-- fragment --><p>There are also <code>requires</code> template parameters for generically checking if a type's <a class="el" href="structstan_1_1value__type.html">stan::value_type</a> or <a class="el" href="structstan_1_1scalar__type.html">stan::scalar_type</a> is correct. To differentiate them from the <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> and standard library vector checks the <code>vt</code> and <code>st</code> come <em>before</em> the type such as <code>require_vt_var&lt;T&gt;</code> which checks if a type <code>T</code>'s <a class="el" href="structstan_1_1value__type.html">stan::value_type</a> satisfies <a class="el" href="structstan_1_1is__var.html">stan::is_var</a>.</p>
<p>The <code>requires</code> template parameters type traits allow Stan to have more generic types so that the library can forward <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression and have better move semantics. For instance, the code below will accept any arbitrary <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression that, if it's an rvalue, can be forwarded to another function.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Mat1, <span class="keyword">typename</span> Mat2,</div>
<div class="line"> require_all_eigen_vt&lt;is_arithmetic, Mat1, Mat2&gt;* = <span class="keyword">nullptr</span>&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keyword">auto</span> a_func(Mat1&amp;&amp; m1, Mat2&amp;&amp; m2) {</div>
<div class="line">  check_not_nan(m1);</div>
<div class="line">  check_not_nan(m2);</div>
<div class="line">  <span class="keywordflow">return</span> another_func(std::forward&lt;Mat1&gt;(m1), std::forward&lt;Mat2&gt;(m2));</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md106"></a>
Adding a new requires</h3>
<p>For a full list of predefined <code>requires</code> template parameters please see <a class="el" href="group__require__meta.html">Available requires&lt;&gt; for overloading.</a>.</p>
<p>If you are adding a new type trait that contains a <code>bool</code> member named value, you can add it to the set of known <code>requires</code> template parameters by using the macros defined in <a class="el" href="require__helpers_8hpp.html">stan/math/prim/meta/require_helpers.hpp</a> .</p>
<p>For an example, we will use the <code>is_double_only</code> type trait below that only has a <code>bool value</code> member equal to <code>true</code> if the type <code>T</code> is <code>double</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>is_double_only</div>
<div class="line">    : <a class="code hl_class" href="classbool__constant.html">bool_constant</a>&lt;std::is_same&lt;double, std::decay_t&lt;T&gt;&gt;::value&gt; {};</div>
<div class="ttc" id="aclassbool__constant_html"><div class="ttname"><a href="classbool__constant.html">bool_constant</a></div></div>
</div><!-- fragment --><p>We can add the associated <code>requires</code> template parameters for the standard requires of <code>require_double_only_t</code> using the <a class="el" href="group__macro__helpers_ga30b34cd5faa42c964f7bcd6ede19f937.html#ga30b34cd5faa42c964f7bcd6ede19f937">STAN_ADD_REQUIRE_UNARY</a> macro. We supply the name to use in the require (<code>double_only</code>), The type trait name (<code>is_double_only</code>) and which group this type trait is in <code>require_stan_scalar_real</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__macro__helpers_ga30b34cd5faa42c964f7bcd6ede19f937.html#ga30b34cd5faa42c964f7bcd6ede19f937">STAN_ADD_REQUIRE_UNARY</a>(double_only, is_double_only,</div>
<div class="line">                       require_stan_scalar_real);</div>
<div class="ttc" id="agroup__macro__helpers_ga30b34cd5faa42c964f7bcd6ede19f937_html_ga30b34cd5faa42c964f7bcd6ede19f937"><div class="ttname"><a href="group__macro__helpers_ga30b34cd5faa42c964f7bcd6ede19f937.html#ga30b34cd5faa42c964f7bcd6ede19f937">STAN_ADD_REQUIRE_UNARY</a></div><div class="ttdeci">#define STAN_ADD_REQUIRE_UNARY(check_type, checker, doxygen_group)</div><div class="ttdoc">Adds Unary require aliases.</div><div class="ttdef"><b>Definition</b> <a href="require__helpers_8hpp_source.html#l00072">require_helpers.hpp:72</a></div></div>
</div><!-- fragment --><p>Similary, we can use the <a class="el" href="group__macro__helpers_ga41284324dab2d2ea77cbbae9db7b8086.html#ga41284324dab2d2ea77cbbae9db7b8086">STAN_ADD_REQUIRE_UNARY_INNER</a> macro to get the <code>requires</code> template parameters such as <code>require_vt_double_only</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_define" href="group__macro__helpers_ga41284324dab2d2ea77cbbae9db7b8086.html#ga41284324dab2d2ea77cbbae9db7b8086">STAN_ADD_REQUIRE_UNARY_INNER</a>(double_only, is_double_only,</div>
<div class="line">                             require_stan_scalar_real);</div>
<div class="ttc" id="agroup__macro__helpers_ga41284324dab2d2ea77cbbae9db7b8086_html_ga41284324dab2d2ea77cbbae9db7b8086"><div class="ttname"><a href="group__macro__helpers_ga41284324dab2d2ea77cbbae9db7b8086.html#ga41284324dab2d2ea77cbbae9db7b8086">STAN_ADD_REQUIRE_UNARY_INNER</a></div><div class="ttdeci">#define STAN_ADD_REQUIRE_UNARY_INNER(check_type, checker, doxygen_group)</div><div class="ttdoc">Adds unary require aliases that check the value_type.</div><div class="ttdef"><b>Definition</b> <a href="require__helpers_8hpp_source.html#l00114">require_helpers.hpp:114</a></div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
